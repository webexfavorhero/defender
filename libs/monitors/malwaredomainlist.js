var debug = require('debug')('malwaredomainlist');

var async = require('async');
var request = require('request');
var csvStream = require('csv-stream');

var log = require('../../td_common/libs/log');
var redis = require("../redis");


var monitor = require('../monitor')('malwaredomainlist');

function checkOne (us, finishCallback) {
  monitor.findInBlocklist(us.url, function (err, flagged, details) {
    var status = flagged ? "malware" : "ok";
    debug('check url ' + us.url + ': ' + status);
    monitor.updateUrlStatusIfDifferent (us, status, details, function (err) {
      finishCallback(err);
    });
  });
}
exports.checkOne = checkOne;

function checkForUpdates (finishCallback) {
  var hasUpdates = false;
  redis.get('malwaredomainlistLastDownloadAt',
            function (err, lastDownloadAt) {
    if (err) {
      return finishCallback(new Error('redis get error: ' + err),
                            hasUpdates);
    }
    debug('lastDownloadAt: ' + lastDownloadAt);
    if (!lastDownloadAt ||
        Date.now() > lastDownloadAt + 60*60*1000) { // 1 hour
      hasUpdates = true;
    }
    return finishCallback(null, hasUpdates);
  });
}

function check (finishCallback) {
  debug('Start malwaredomainlist monitor checking...');
  async.waterfall([
    function updatedOrNot (callback) {
      if (monitor.options.skipCheckForUpdates) {
        log.warn('ATENTION!!! malwaredomainlist monitor skips check for ' +
                 'updates.');
        callback(null);
      } else {
        checkForUpdates (function (err, hasUpdates) {
          if (!hasUpdates) {
            debug('malwaredomainlist doesn\'t has updates');
            return callback(true);
          }
          debug('malwaredomainlist has updates. Downloading and checking...');
          callback(null);
        });
      }
    },
    function startUpdatingBlocklist (callback) {
      if (monitor.options.skipUpdates) {
        callback(null);
      } else {
        monitor.startUpdatingBlocklist (function (err) {
          callback(err);
        });
      }
    },
    function downloadDatabaseAndUpdate (callback) {
      if (monitor.options.skipUpdates) {
        log.warn('ATENTION!!! malwaredomainlist monitor skips updates.');
        callback(null);
      } else {
        debug('monitor.options.databaseUrl: ' + monitor.options.databaseUrl);

        var csvOptions = {
          delimiter : ',',
          endLine : '\n',
          columns : [
            'dateUtc',
            'urlWithoutProto',
            'ip',
            'reverseLookup',
            'description',
            'registrant',
            'asn',
            'field1',
            'countryCode',
            'field2',
          ],
          escapeChar : '"',
          enclosedChar : '"'
        };

        var csv = csvStream.createStream(csvOptions);
        request({
          url: monitor.options.databaseUrl,
        }).pipe(csv)
          .on('error',function (err) {
            debug('err: ' + err);
            return callback(err);
          })
          .on('data',function (record) {
            if (record.dateUtc) {
              var url;
              if (record.urlWithoutProto !== '-') {
                url = 'http://' + record.urlWithoutProto;
              } else {
                url = 'http://' + record.ip.replace(/\.$/, '');
                                        // remove '.' if last character is '.'
              }
              debug('url: ', url);
              debug('record: ', JSON.stringify(record));
              monitor.updateInBlocklist (url, record, function(err) {
                if (err) {
                  log.error('malwaredomainlist update in blocklist ' +
                            'error: ' + err);
                }
              });
            }
          })
          .on('end', function () {
            debug('parse end');
            var lastDownloadAt = new Date();
            redis.set('malwaredomainlistLastDownloadAt',
                      lastDownloadAt.valueOf());
            log.info('Database update from malwaredomainlist has been ' +
                     'downloaded, lastDownloadAt: ' +
                     lastDownloadAt.toISOString());
            return callback(null);
          });
      }
    },
    function completeUpdatingBlocklist (callback) {
      if (monitor.options.skipUpdates) {
        callback(null);
      } else {
        monitor.completeUpdatingBlocklist (function (err) {
          callback(err);
        });
      }
    },
    function findUss (callback) {
      monitor.findUrlStatusesForPlan(null, function(err, uss) {
        if (!uss) {
          return callback(true);
        }
        async.each(uss, function (us, eachCallback) {
          checkOne (us, eachCallback);
        }, function (err) {
          callback(err, uss);
        });
      });
    },
    function incHitsAndSaveUss (uss, callback) {
      monitor.incUrlStatusesHits(uss);
      monitor.saveUrlStatuses(uss, callback);
    }
  ], function finish (err) {
    if (err === true) {
      // do nothing
    } else if (err) {
      log.error('malwaredomainlist monitor error: ' + err);
    }
    debug('malwaredomainlist monitor check was over');
    if (finishCallback) {
      finishCallback(null);
    }
  });
}
exports.check = check;

